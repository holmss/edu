\section{Описание}Параллельное программирование -- это техника программирования, которая использует преимущества многоядерных или многопроцесорных компьютеров и является подмножеством более широкого понятия многопоточности (multithreading). \\Параллельное программирование может быть сложным, но его легче понять, если считать его не ``трудным`` , а просто ``немного иным``. Оно включает в себя все черты более традиционного, последовательного программирования, но в параллельном прогаммировании имеются три дополнительных, четко определенных этапа:\begin{itemize}\item{Определение параллелизма: анализ задачи с целью выделить подзадачи, которые могут выполняться одновременно.}\item{Выявление параллелизма: изменение структуры задачи таким образом, чтобы можно было эффективно выполнять подзадачи. Для этого часто требуется найти зависимости между подзадачами и организовать исходный код так, чтобы ими можно было эффективно управлять.}\item{Выражение параллелизма: реализация параллельного алгоритма в исходном коде с помощью системы обозначений параллельного программирования.}\end{itemize}\section{Исходный код}Описание классов фигур и методов класса-контейнера, определенных раннее, остается неизменным.\\\begin{lstlisting}[language=C]template <class T>std::shared_ptr<TListItem<T>> TList<T>::PSort(std::shared_ptr<TListItem<T>> &head){    if (head == nullptr || head->GetNext() == nullptr) {        return head;    }    std::shared_ptr<TListItem<T>> partitionedEl = Partition(head);    std::shared_ptr<TListItem<T>> leftPartition = partitionedEl->GetNext();    std::shared_ptr<TListItem<T>> rightPartition = head;    partitionedEl->SetNext(nullptr);    if (leftPartition == nullptr) {        leftPartition = head;        rightPartition = head->GetNext();        head->SetNext(nullptr);    }    rightPartition = PSort(rightPartition);    leftPartition = PSort(leftPartition);    std::shared_ptr<TListItem<T>> iter = leftPartition;    while (iter->GetNext() != nullptr) {        iter = iter->GetNext();    }    iter->SetNext(rightPartition);    return leftPartition;}template <class T>std::shared_ptr<TListItem<T>> TList<T>::Partition(std::shared_ptr<TListItem<T>> &head){    std::lock_guard<std::mutex> lock(mutex);    if (head->GetNext()->GetNext() = nullptr) {        if (head->GetNext()->GetFigure()->Square() > head->GetFigure()->Square()) {            return head->GetNext();        } else {            return head;        }    } else {        std::shared_ptr<TListItem<T>> i = head->GetNext();        std::shared_ptr<TListItem<T>> pivot = head;        std::shared_ptr<TListItem<T>> lastElSwapped = (pivot->GetNext()->GetFigure()->Square() >= pivot->GetFigure()->Square()) ? pivot->GetNext() : pivot;        while ((i != nullptr) && (i->GetNext() != nullptr)) {            if (i->GetNext()->GetFigure()->Square() >= pivot->GetFigure()->Square()) {                if (i->GetNext() == lastElSwapped->GetNext()) {                    lastElSwapped = lastElSwapped->GetNext();                } else {                    std::shared_ptr<TListItem<T>> tmp = lastElSwapped->GetNext();                    lastElSwapped->SetNext(i->GetNext());                    i->SetNext(i->GetNext()->GetNext());                    lastElSwapped = lastElSwapped->GetNext();                    lastElSwapped->SetNext(tmp);                }            }            i = i->GetNext();        }        return lastElSwapped;    }}template <class T>void TList<T>::Sort(){    if (head == nullptr)        return;    std::shared_ptr<TListItem<T>> tmp = head->GetNext();    head->SetNext(PSort(tmp));}template <class T>void TList<T>::ParSort(){    if (head == nullptr)        return;    std::shared_ptr<TListItem<T>> tmp = head->GetNext();    head->SetNext(PParSort(tmp));}template <class T>std::shared_ptr<TListItem<T>> TList<T>::PParSort(std::shared_ptr<TListItem<T>> &head){    if (head == nullptr || head->GetNext() == nullptr) {        return head;    }    std::shared_ptr<TListItem<T>> partitionedEl = Partition(head);    std::shared_ptr<TListItem<T>> leftPartition = partitionedEl->GetNext();    std::shared_ptr<TListItem<T>> rightPartition = head;    partitionedEl->SetNext(nullptr);    if (leftPartition == nullptr) {        leftPartition = head;        rightPartition = head->GetNext();        head->SetNext(nullptr);    }    std::packaged_task<std::shared_ptr<TListItem<T>>(std::shared_ptr<TListItem<T>>&)>        task1(std::bind(&TList<T>::PParSort, this, std::placeholders::_1));    std::packaged_task<std::shared_ptr<TListItem<T>>(std::shared_ptr<TListItem<T>>&)>        task2(std::bind(&TList<T>::PParSort, this, std::placeholders::_1));    auto rightPartitionHandle = task1.get_future();    auto leftPartitionHandle = task2.get_future();    std::thread(std::move(task1), std::ref(rightPartition)).join();    rightPartition = rightPartitionHandle.get();    std::thread(std::move(task2), std::ref(leftPartition)).join();    leftPartition = leftPartitionHandle.get();    std::shared_ptr<TListItem<T>> iter = leftPartition;    while (iter->GetNext() != nullptr) {        iter = iter->GetNext();    }    iter->SetNext(rightPartition);    return leftPartition;}\end{lstlisting}\section{Консоль}\begin{alltt}karma@karma:~/mai_study/OOP/lab8$ ./runChoose an operation:1) Add trapeze2) Add rhomb3) Add pentagon4) Delete figure from list5) Sort list6) Print list0) Exit3Enter side: 5Enter index = 0Choose an operation:1) Add trapeze2) Add rhomb3) Add pentagon4) Delete figure from list5) Sort list6) Print list0) Exit2Enter side: 5Enter smaller angle: 30Enter index = 0Choose an operation:1) Add trapeze2) Add rhomb3) Add pentagon4) Delete figure from list5) Sort list6) Print list0) Exit1Enter bigger base: 5Enter smaller base: 4Enter left side: 4Enter right side: 4Enter index = 1Choose an operation:1) Add trapeze2) Add rhomb3) Add pentagon4) Delete figure from list5) Sort list6) Print list0) Exit3Enter side: 10Enter index = 2Choose an operation:1) Add trapeze2) Add rhomb3) Add pentagon4) Delete figure from list5) Sort list6) Print list0) Exit6idx: 0   Side = 5, smaller_angle = 30, square = 12.5, type: rhombidx: 1   Sides =  5, square = 43.0119, type: pentagonidx: 2   Smaller base = 4, bigger base = 5, left side = 4, right side = 4, square = 7.96863, type: trapezeidx: 3   Sides =  10, square = 172.048, type: pentagonChoose an operation:1) Add trapeze2) Add rhomb3) Add pentagon4) Delete figure from list5) Sort list6) Print list0) Exit51 to regular sort, 2 to parallel2idx: 0   Smaller base = 4, bigger base = 5, left side = 4, right side = 4, square = 7.96863, type: trapezeidx: 1   Side = 5, smaller_angle = 30, square = 12.5, type: rhombidx: 2   Sides =  5, square = 43.0119, type: pentagonidx: 3   Sides =  10, square = 172.048, type: pentagonChoose an operation:1) Add trapeze2) Add rhomb3) Add pentagon4) Delete figure from list5) Sort list6) Print list0) Exit6idx: 0   Smaller base = 4, bigger base = 5, left side = 4, right side = 4, square = 7.96863, type: trapezeidx: 1   Side = 5, smaller_angle = 30, square = 12.5, type: rhombidx: 2   Sides =  5, square = 43.0119, type: pentagonidx: 3   Sides =  10, square = 172.048, type: pentagonChoose an operation:1) Add trapeze2) Add rhomb3) Add pentagon4) Delete figure from list5) Sort list6) Print list0) Exit2Enter side: 50Enter smaller angle: 90Enter index = 0Choose an operation:1) Add trapeze2) Add rhomb3) Add pentagon4) Delete figure from list5) Sort list6) Print list0) Exit3Enter side: 10000Enter index = 0Choose an operation:1) Add trapeze2) Add rhomb3) Add pentagon4) Delete figure from list5) Sort list6) Print list0) Exit6idx: 0   Sides =  10000, square = 1.72048e+08, type: pentagonidx: 1   Side = 50, smaller_angle = 90, square = 2500, type: rhombidx: 2   Smaller base = 4, bigger base = 5, left side = 4, right side = 4, square = 7.96863, type: trapezeidx: 3   Side = 5, smaller_angle = 30, square = 12.5, type: rhombidx: 4   Sides =  5, square = 43.0119, type: pentagonidx: 5   Sides =  10, square = 172.048, type: pentagonChoose an operation:1) Add trapeze2) Add rhomb3) Add pentagon4) Delete figure from list5) Sort list6) Print list0) Exit51 to regular sort, 2 to parallel1idx: 0   Smaller base = 4, bigger base = 5, left side = 4, right side = 4, square = 7.96863, type: trapezeidx: 1   Side = 5, smaller_angle = 30, square = 12.5, type: rhombidx: 2   Sides =  5, square = 43.0119, type: pentagonidx: 3   Sides =  10, square = 172.048, type: pentagonidx: 4   Side = 50, smaller_angle = 90, square = 2500, type: rhombidx: 5   Sides =  10000, square = 1.72048e+08, type: pentagonChoose an operation:1) Add trapeze2) Add rhomb3) Add pentagon4) Delete figure from list5) Sort list6) Print list0) Exit0\end{alltt}