\section{Описание}Динамические структуры данных используются в тех случаях, когда мы заранее не знаем, сколько памяти необходимо выделить для нашей программы -- это выясняется только в процессе работы. В общем случае эта структура представляет собо отдельные элементы, связанные между собой с помощью ссылок. Каждый элемент состоит из двух областей памяти: поля данных и ссылок. Ссылки -- это адреса других узлов того же типа, с которыми данный элемент логически связан. При добавлении нового элемента в такую структуру выделяется новый блок памяти и устанавливаются связи этого элемента с уже существующими. \\Структура данных список является простейшим типом данных динамической структуры, состоящей из узлов. Каждый узел включает в себя в классическом варианте два поля: данные и указатель на следующий узел в списке. Элементы связного списка можно вставлять и удалять произвольным образом. Доступ к списку осуществляется через указатель, который содержит ядрес первого элемента списка, называемого головой списка. \\Параметры в функцию могут передаваться одним из следующих способов: по значению и по ссылке. При передаче аргументов по значению компилятор создает временную копию объекта, который должен быть передан, и размещает его в области стековой памяти, предназначенной для хранения локальных объектов. Вызываемая функция оперирует именно с этой копией, не оказывая влияния на оригинал объекта. Прототипы функций, принимающих аргументы по значению, предусматривают в качестве параметров указание типа объекта,а не его адреса. Если же необходимо, чтобы функция модифицировала оригинал объекта, используется передача параметров по ссылке. При этом в функцию передается не сам объект, а только его адрес. Таким образом, все модификации в теле функции переданных ей по ссылке аргументов воздействуют на объект. Использование передачи адреса объекта весьма эффективный способ работы с большим числом данных. Кроме того, так как передается адрес, а не сам объект, существенно экономится стековая память. \\\section{Исходный код}\begin{longtable}{|p{7.5cm}|p{7.5cm}|}\hline\rowcolor{lightgray}\multicolumn{2}{|c|} {trapeze.cpp}\\\hlineTrapeze();&Конструктор класса\\\hlineTrapeze(std::istream \&is);&Конструктор класса из стандартного потока\\\hlineTrapeze(const Trapeze\& orig);&Конструктор копии класса\\\hlinedouble Square();&Площадь фигуры\\\hlinevoid Print();&Печать фигуры\\\hline\textasciitilde Trapeze();&Деконструктор класса\\\hlinebool operator ==(const Trapeze \&obj) const;&Переопределенный оператор сравнения\\\hlineTrapeze\& operator =(const Trapeze \&obj);&Переопределенный оператор копирования\\\hlinefriend std::ostream\& operator <<(std::ostream \&os, const Trapeze \&obj);&Переопределенный оператор вывода в поток std::ostream\\\hlinefriend std::istream\& operator >>(std::istream \&is, Trapeze \&obj);&Переопределенный оператор ввода из потока std::istream\\\hline\rowcolor{lightgray}\multicolumn{2}{|c|} {TListItem.cpp}\\\hlineTListItem(const Trapeze \&obj);&Конструктор класса\\\hlineTrapeze GetFigure() const;&Получение фигуры из узла\\\hlineTListItem* GetNext();&Получение ссылки на следующий узел\\\hlineTListItem* GetPrev();&Получение ссылки на предыдущий узел\\\hlinevoid SetNext(TListItem *item);&Установка ссылки на следующий узел\\\hlinevoid SetPrev(TListItem *item);&Установка ссылки на предыдущий узел\\\hlinefriend std::ostream\& operator<<(std::ostream \&os, const TListItem \&obj);&Переопределенный оператор вывода в поток std::ostream\\\hlinevirtual \textasciitilde TListItem(){};&Деконструктор класса\\\hline\rowcolor{lightgray}\multicolumn{2}{|c|} {TList.cpp}\\\hlineTList();&Конструктор класса\\\hlinevoid Push(Trapeze \&obj);&Добавление фигуры в список\\\hlineTrapeze Pop();&Получение фигуры из списка\\\hlineconst bool IsEmpty() const;&Проверка, пуст ли список\\\hlineuint32t GetLength();&Получение длины списка\\\hlinefriend std::ostream\& operator<<(std::ostream \&os, const TList \&list);&Переопределенный оператор вывода в поток std::ostream\\\hlinevirtual \textasciitilde TList();&Деконструктор класса\\\hline\end{longtable}\begin{lstlisting}[language=C]class TList{public:    TList();    void Push(Trapeze &obj);    const bool IsEmpty() const;    uint32_t GetLength();    Trapeze Pop();    friend std::ostream& operator<<(std::ostream &os, const TList &list);    virtual ~TList();private:    uint32_t length;    TListItem *head;    void PushFirst(Trapeze &obj);    void PushLast(Trapeze &obj);    void PushAtIndex(Trapeze &obj, int32_t ind);    Trapeze PopFirst();    Trapeze PopLast();    Trapeze PopAtIndex(int32_t ind);};class TListItem{public:    TListItem(const Trapeze &obj);    Trapeze GetFigure() const;    TListItem* GetNext();    TListItem* GetPrev();    void SetNext(TListItem *item);    void SetPrev(TListItem *item);    friend std::ostream& operator<<(std::ostream &os, const TListItem &obj);    virtual ~TListItem(){};private:    Trapeze item;    TListItem *next;    TListItem *prev;};class Trapeze : public Figure{public:    Trapeze();    Trapeze(std::istream &is);    Trapeze(int32_t small_base, int32_t big_base, int32_t l_side, int32_t r_side);    Trapeze(const Trapeze &orig);    bool operator ==(const Trapeze &obj) const;    Trapeze& operator =(const Trapeze &obj);    friend std::ostream& operator <<(std::ostream &os, const Trapeze &obj);    friend std::istream& operator >>(std::istream &is, Trapeze &obj);    double Square() override;    void Print() override;    virtual ~Trapeze();private:    int32_t small_base;    int32_t big_base;    int32_t l_side;    int32_t r_side;};\end{lstlisting}\section{Консоль}\begin{alltt}karma@karma:~/mai_study/OOP/lab2$ valgrind --leak-check=full ./run==4059== Memcheck, a memory error detector==4059== Copyright (C) 2002-2015, and GNU GPL'd, by Julian Seward et al.==4059== Using Valgrind-3.11.0 and LibVEX; rerun with -h for copyright info==4059== Command: ./run==4059== Choose an operation:1) Add trapeze2) Delete trapeze from list3) Print list0) Exit3The list is empty.Choose an operation:1) Add trapeze2) Delete trapeze from list3) Print list0) Exit1Enter bigger base: 5Enter smaller base: 2Enter left side: 1Enter right side: 1Enter index = 0Choose an operation:1) Add trapeze2) Delete trapeze from list3) Print list0) Exit1Enter bigger base: 4Enter smaller base: 3Enter left side: 3Enter right side: 3Enter index = 0Choose an operation:1) Add trapeze2) Delete trapeze from list3) Print list0) Exit1Enter bigger base: 5Enter smaller base: 5Enter left side: 5Enter right side: 5Enter index = 1Choose an operation:1) Add trapeze2) Delete trapeze from list3) Print list0) Exit1Enter bigger base: 2Enter smaller base: 2Enter left side: 2Enter right side: 2Enter index = 2Choose an operation:1) Add trapeze2) Delete trapeze from list3) Print list0) Exit3idx: 0   (3 4 3 3)idx: 1   (2 5 1 1)idx: 2   (5 5 5 5)idx: 3   (2 2 2 2)Choose an operation:1) Add trapeze2) Delete trapeze from list3) Print list0) Exit2Enter index = 1Choose an operation:1) Add trapeze2) Delete trapeze from list3) Print list0) Exit2Enter index = 1Choose an operation:1) Add trapeze2) Delete trapeze from list3) Print list0) Exit2Enter index = 1Choose an operation:1) Add trapeze2) Delete trapeze from list3) Print list0) Exit3idx: 0   (3 4 3 3)Choose an operation:1) Add trapeze2) Delete trapeze from list3) Print list0) Exit1Enter bigger base: 3Enter smaller base: 3Enter left side: 3Enter right side: 3Enter index = 0Choose an operation:1) Add trapeze2) Delete trapeze from list3) Print list0) Exit1Enter bigger base: 2Enter smaller base: 2Enter left side: 2Enter right side: 2Enter index = 1Choose an operation:1) Add trapeze2) Delete trapeze from list3) Print list0) Exit3idx: 0   (3 3 3 3)idx: 1   (3 4 3 3)idx: 2   (2 2 2 2)Choose an operation:1) Add trapeze2) Delete trapeze from list3) Print list0) Exit0==4059== ==4059== HEAP SUMMARY:==4059==     in use at exit: 72,704 bytes in 1 blocks==4059==   total heap usage: 9 allocs, 8 frees, 75,040 bytes allocated==4059== ==4059== LEAK SUMMARY:==4059==    definitely lost: 0 bytes in 0 blocks==4059==    indirectly lost: 0 bytes in 0 blocks==4059==      possibly lost: 0 bytes in 0 blocks==4059==    still reachable: 72,704 bytes in 1 blocks==4059==         suppressed: 0 bytes in 0 blocks==4059== Reachable blocks (those to which a pointer was found) are not shown.==4059== To see them, rerun with: --leak-check=full --show-leak-kinds=all==4059== ==4059== For counts of detected and suppressed errors, rerun with: -v==4059== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)\end{alltt}