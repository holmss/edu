\section{Описание}Лямбда-выражение -- это удобный способ определения анонимного объекта-функции непосредственно в месте его вызова или передачи в функцию в качестве аргумента. Обычно лямбда-выражения используются для инкапсуляции нескольких строк кода, передаваемых алгоритмам или асинхронным методам. В итоге, мы получаем крайне удобную конструкцию, которая позволяет сделать код более лаконичным и устойчивым к изменениям. \\Непосредственное объявление лямбда-функции состоит из трех частей. Первая часть (квадратные скобки) позволяет привязывать переменные, доступные в текущей области видимости. Вторая часть (круглые скобки) указывает список принимаемых параметров лямбда-функции. Третья часть (фигурные скобки) содержит тело лямбда-функции. \\В настоящее время, учитывая, что достигли практически потолка по тактовой частоте и дальше идет рост количества ядер, появился запрос на параллелизм. В результате снова в моде стал функциональный подход, так как он очень хорошо работает в условиях параллелизма и не требует явных синхронизаций. Поэтому сейчас усиленно думают, как задействовать растущее число ядер процессора и как обеспечить автоматическое распараллеливание. А в функциональном программировании практически основа всего -- лямбда. Учитывая, что функциональные языки переживают второе рождение, было бы странным, если бы функциональный подход не добавляли во все популярные языки. С++ -- язык, поддерживающий много парадигм, поэтому нет ничего странного в использовании лямбда-функций и лямбда-выражений в нем. \\\section{Исходный код}Описание классов фигур и классов-контейнеров, определенных раннее, остается неизменным.\\\begin{lstlisting}[language=C]int main(void){    TList<Figure> list;    typedef std::function<void(void)> Command;    TStack<std::shared_ptr<Command>> stack;    std::mutex mtx;    Command cmdInsert = [&]() {        std::lock_guard<std::mutex> guard(mtx);        uint32_t seed = std::chrono::system_clock::now().time_since_epoch().count();        std::default_random_engine generator(seed);        std::uniform_int_distribution<int> distFigureType(1, 3);        std::uniform_int_distribution<int> distFigureParam(1, 10);        for (int i = 0; i < 10; ++ i) {            std::cout << "Command: Insert" << std::endl;            switch(distFigureType(generator)) {                case 1: {                    std::cout << "Inserted trapeze" << std::endl;                    int32_t big_base = distFigureParam(generator);                    int32_t small_base = distFigureParam(generator);                    int32_t l_side = distFigureParam(generator);                    int32_t r_side = distFigureParam(generator);                    list.PushFirst(std::shared_ptr<Trapeze>(new Trapeze(small_base, big_base, l_side, r_side)));                    break;                }                case 2: {                    std::cout << "Inserted rhomb" << std::endl;                    int32_t side = distFigureParam(generator);                    int32_t small_angle = distFigureParam(generator);                    list.PushFirst(std::shared_ptr<Rhomb>(new Rhomb(side, small_angle)));                    break;                }                case 3: {                    std::cout << "Inserted pentagon" << std::endl;                    int32_t side = distFigureParam(generator);                    list.PushFirst(std::shared_ptr<Pentagon>(new Pentagon(side)));                    break;                }            }        }    };    Command cmdRemove = [&]() {        std::lock_guard<std::mutex> guard(mtx);        std::cout << "Command: Remove" << std::endl;        if (list.IsEmpty()) {            std::cout << "List is empty" << std::endl;        } else {            uint32_t seed = std::chrono::system_clock::now().time_since_epoch().count();            std::default_random_engine generator(seed);            std::uniform_int_distribution<int> distSquare(1, 150);            double sqr = distSquare(generator);            std::cout << "Lesser than " << sqr << std::endl;            for (int32_t i = 0; i < 10; ++i) {                auto iter = list.begin();                for (int32_t k = 0; k < list.GetLength(); ++k) {                    if (iter->Square() < sqr) {                        list.Pop(k);                        break;                    }                    ++iter;                }            }        }    };    Command cmdPrint = [&]() {        std::lock_guard<std::mutex> guard(mtx);        std::cout << "Command: Print" << std::endl;        if(!list.IsEmpty()) {            std::cout << list << std::endl;        } else {            std::cout << "List is empty." << std::endl;        }    };    stack.Push(std::shared_ptr<Command>(&cmdPrint, [](Command*){}));    stack.Push(std::shared_ptr<Command>(&cmdRemove, [](Command*){}));    stack.Push(std::shared_ptr<Command>(&cmdPrint, [](Command*){}));    stack.Push(std::shared_ptr<Command>(&cmdInsert, [](Command*){}));    while (!stack.IsEmpty()) {        std::shared_ptr<Command> cmd = stack.Top();        std::future<void> ft = std::async(*cmd);        ft.get();        stack.Pop();    }    return 0;}\end{lstlisting}\section{Консоль}\begin{alltt}karma@karma:~/mai_study/OOP/lab9$ ./runCommand: InsertInserted trapezeCommand: InsertInserted trapezeCommand: InsertInserted pentagonCommand: InsertInserted rhombCommand: InsertInserted rhombCommand: InsertInserted pentagonCommand: InsertInserted trapezeCommand: InsertInserted trapezeCommand: InsertInserted rhombCommand: InsertInserted trapezeCommand: Printidx: 0   Smaller base = 6, bigger base = 9, left side = 10, right side = 10, square = 16.8869, type: trapezeidx: 1   Side = 3, smaller_angle = 2, square = 0.314095, type: rhombidx: 2   Smaller base = 7, bigger base = 9, left side = 5, right side = 8, square = -1, type: trapezeidx: 3   Smaller base = 6, bigger base = 9, left side = 4, right side = 3, square = 10.1225, type: trapezeidx: 4   Sides =  6, square = 61.9372, type: pentagonidx: 5   Side = 1, smaller_angle = 1, square = 0.0174524, type: rhombidx: 6   Side = 2, smaller_angle = 2, square = 0.139598, type: rhombidx: 7   Sides =  6, square = 61.9372, type: pentagonidx: 8   Smaller base = 2, bigger base = 10, left side = 3, right side = 4, square = -1, type: trapezeidx: 9   Smaller base = 1, bigger base = 8, left side = 8, right side = 5, square = 9.2915, type: trapezeCommand: RemoveLesser than 16Command: Printidx: 0   Smaller base = 6, bigger base = 9, left side = 10, right side = 10, square = 16.8869, type: trapezeidx: 1   Sides =  6, square = 61.9372, type: pentagonidx: 2   Sides =  6, square = 61.9372, type: pentagon\end{alltt}