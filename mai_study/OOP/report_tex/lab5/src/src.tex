\section{Описание}Для доступа к элементам некоторого множества элементов используют специальные объекты, называемые итераторами. В контейнерных типах stl они доступны через методы класса (например, begin() в шаблоне класса vector). Функциональные возможности указателей и итераторов близки, так что обычный указатель тоже может использоваться как итератор.\\Категории итераторов:\begin{itemize}\item{Итератор ввода (input iterator) -- используется потоками ввода.}\item{Итератор вывода (output iterator) -- используется потоками вывода.}\item{Однонаправленный итератор (forward iterator) -- для прохода по элементам в одном направлении.}\item{Двунаправленный итератор (bidirectional iterator) -- способен пройти по элементам в любом направлении. Такие итераторы реализованы в некоторых контейнерных типах stl (list, set, multiset, map, multimap).}\item{Итераторы произвольного доступа (random access) -- через них можно иметь доступ к любому элементу. Такие итераторы реализованы в некоторых контейнерных типах stl (vector, deque, string, array).}\end{itemize}\section{Исходный код}Описание классов фигур и класса-контейнера остается неизменным.\begin{lstlisting}[language=C]template <class N, class T>class TIterator{public:    TIterator(std::shared_ptr<N> n) {        cur = n;    }    std::shared_ptr<T> operator* () {        return cur->GetFigure();    }    std::shared_ptr<T> operator-> () {        return cur->GetFigure();    }    void operator++() {        cur = cur->GetNext();    }    TIterator operator++ (int) {        TIterator cur(*this);        ++(*this);        return cur;    }    void operator--() {        cur = cur->GetPrev();    }    TIterator operator-- (int) {        TIterator cur(*this);        --(*this);        return cur;    }    bool operator== (const TIterator &i) {        return (cur == i.cur);    }    bool operator!= (const TIterator &i) {        return (cur != i.cur);    }private:    std::shared_ptr<N> cur;};\end{lstlisting}\section{Консоль}\begin{alltt}karma@karma:~/mai_study/OOP/lab5$ ./runChoose an operation:1) Add trapeze2) Add rhomb3) Add pentagon4) Delete figure from list5) Print list6) Print list with iterator0) Exit2Enter side: 10Enter smaller angle: 10Enter index = 0Choose an operation:1) Add trapeze2) Add rhomb3) Add pentagon4) Delete figure from list5) Print list6) Print list with iterator0) Exit2Enter side: 9Enter smaller angle: 20Enter index = 0Choose an operation:1) Add trapeze2) Add rhomb3) Add pentagon4) Delete figure from list5) Print list6) Print list with iterator0) Exit1Enter bigger base: 9Enter smaller base: 8Enter left side: 7Enter right side: 6Enter index = 1Choose an operation:1) Add trapeze2) Add rhomb3) Add pentagon4) Delete figure from list5) Print list6) Print list with iterator0) Exit3Enter side: 5Enter index = 0Choose an operation:1) Add trapeze2) Add rhomb3) Add pentagon4) Delete figure from list5) Print list6) Print list with iterator0) Exit5idx: 0   Sides =  5, type: pentagonidx: 1   Side = 9, smaller_angle = 20, type: rhombidx: 2   Side = 10, smaller_angle = 10, type: rhombidx: 3   Smaller base = 8, bigger base = 9, left side = 7, right side = 6, type: trapezeChoose an operation:1) Add trapeze2) Add rhomb3) Add pentagon4) Delete figure from list5) Print list6) Print list with iterator0) Exit4Enter index = 2Choose an operation:1) Add trapeze2) Add rhomb3) Add pentagon4) Delete figure from list5) Print list6) Print list with iterator0) Exit6Sides =  5, type: pentagonSide = 9, smaller_angle = 20, type: rhombSmaller base = 8, bigger base = 9, left side = 7, right side = 6, type: trapezeChoose an operation:1) Add trapeze2) Add rhomb3) Add pentagon4) Delete figure from list5) Print list6) Print list with iterator0) Exit0\end{alltt}