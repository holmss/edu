# Реферат
## по курсу "Логическое программирование"

### студентка: Довженко А.

## Типовые и бестиповые логические языки: обзор и сравнение.

### Откуда возникла типизация

Типы используются в программировании для ограничения базового синтаксиса, чтобы разрешались только значимые выражения. Это позволяет компилятору обнаружить большинство типографических ошибок и несоответствий в представлении знаний.

Зачем нужны типы данных? Во-первых, переменная должна находиться в памяти и занимать определенное количество места. Поэтому когда мы пишем тип, компилятору становится понятно, какой объем памяти нужно будет выделить под переменную. Во-вторых, тип это некий способ интерпретации, мы определяем для переменной некоторый тип и после этого не сможем с ней делать действия, которые не предусматривает тип. Таким образом, тип влияет на то, как ведет себя переменная при взаимодействии с другими переменными.

### Понятие типа в императивных языках

Изначально понятие типа данных возникло в императивных языках программирования в связи с понятием переменной. Поскольку в императивных языках переменная является именованным аналогом участка памяти компьютера для хранения значений, то системам программирования было удобно заранее знать, какой объем памяти нужно выделять под переменную и как интерпретировать двоичные значения, находящиеся в памяти по соответствующему адресу. Тип данных, таким образом, указывает на характер хранимых в переменной значений, который некоторым образом (при помощи описания типа, либо с помощью умолчаний) фиксируется до того, как с переменной производятся какие-либо операции.

С формальной точки зрения в императивных языках под типом данных понимают некоторое свойство, приписываемое переменной, которое определяет множество значений, которые может принимать переменная этого типа, и множество операций и отношений, которые можно выполнять со значениями типа.

В логическом программировании все по-другому. В логических языках не нужно выделять память под переменные, потому что переменная – это всегда ссылка на некоторую структуру памяти, которая может быть очень разной. Переменная может унифицироваться с разными объектами и со структурными термами произвольной сложности. Само понятие переменной здесь совсем другое, мы никогда заранее не знаем, какой объем памяти понадобится, чтобы хранить соответствующую структуру. Зачем тогда нужна типизация в логических языках? Типизация позволяет избегать большого количества ошибок. Мы не всегда знаем, какие объекты какого порядка нужно передавать предикату. Когда мы пишем предикат, мы естественно понимаем, чем является каждый аргумент, и на какой позиции он находится. Но потом, когда мы захотим использовать этот предикат где-то еще, мы можем легко забыть о его сигнатуре и, например, передать параметры в другом порядке. В этом случае в Прологе программа просто завершится с неуспехом, и мы не узнаем, что ошиблись в порядке передаваемых аргументов, и будем долго думать, почему наша программа не возвращает результатов. Как становится понятно, ошибка может быть где угодно в программе, но компилятор никак не поможет нам эту ошибку обнаружить, если у нас нет поверх используемого языка некоторой системы типов. Как известно, Пролог язык бестиповый, потому что в нем переменная может унифицироваться с чем угодно, и поэтому у нас нет никакой помощи в такого рода ситуации. Существуют некоторые надстройки над бестиповыми языками и типовые логические языки, которые позволяют ввести типизацию.

К дополнительным плюсам типизации можно отнести тот факт, что пользователю проще отлавливать такие ошибки. Типизация позволяет более эффективно строить выполняемый код, потому что если у нас переменные указывают куда-то, то нам каждый раз перед тем как вычислить выражение, нужно делать некие проверки, чтобы узнать, что именно находится в переменной. Вместе с переменной неявным образом хранится информация о типе, в случае со строгой типизацией, которая проходит на этапе компиляции, мы заранее  можем генерировать код уже с учетом этих типов данных.

Проверка типов в рамках логического программирования полезна по нескольким причинам:

 1. Типовые декларации и проверка типа во время компиляции обеспечивают уверенность в правильности программы.
 2. Программа становится более читабельной и понятной.

Ошибки в логических программах, как правило, подразделяются на несколько категорий. Одной из них является плохое взаимодействие между предикатами. Это может быть вызвано неправильным упорядочением аргументов в вызове, неправильным типом передаваемого аргумента или орфографически-неправильными именами переменных. Некоторые из этих ошибок могут быть обнаружены с помощью проверки типа.

### Классификация языков

В зависимости от того, насколько существенны ограничения по объявлению типов, различают:

 1. Языки со строго типизацией, в которых соответствие типов выражений последовательно и строго соблюдается. 
 2. Языки с нестрогой типизацией, в которых тип данных используется в основном для определения размера выделяемой под переменную памяти. Одни типы можно приводить к другим, но если типы совсем не совместимы, то компилятор не даст нам провести операцию с ними или применять какие-то операции к ним.
 3. Бестиповые языки, в которых переменные могут принимать произвольные значения различной природы по ходу выполнения программы. Иными словами можно считать, что эти языки имеют один универсальный тип данных, покрывающий все возможные в рамках языка объекты. 

Уровень типизации языка не может быть определен строго и причислен к одной из упомянутых групп. Разделение весьма условно.
Если говорить о разработке ПО вообще, то наблюдаются следующие закономерности:

 1. Использование языков с сильной типизацией замедляет изначальный процесс разработки, однако существенно сокращает отладку, поскольку множество ошибок, вызванных несоответствием типов, выявляются еще на этапе компиляции.
 2. Бестиповые языки более удобны для быстрого прототипирования и позволяют создавать работоспособные программы как можно скорее. Однако, полученные программы требуют более тщательной отладки и, как правило, в результате содержат больше ошибок.

Таким образом, внесение типизации в неимперативные парадигмы программирования позволяет приблизить соответствующие языки к стандартам систем промышленной разработки. Однако, внедрение понятия типа в такой вычислительный формализм, как логика предикатов, требует определенного математического уточнения понятия типа данных.

### Статический и динамический контроль типов

Различают 2 вида контроля типизации в языках программирования:

 1. Статический, когда типы данных для всех выражений проверяются по тексту программы до ее выполнения, т.е. на этапе компиляции. Большинство ошибок типизации обнаруживаются на этапе компиляции, если, например, допущена ошибка при передаче в функцию неверных аргументов, то мы узнаем об этом еще до выполнения программы. Но в традиционных языках это обычно требует избыточного описания типов в программе, либо система программирования имеет такой механизм как вывод типов и догадывается о том, что же программист имел в виду.
 2. Динамический, осуществляемый в процессе выполнения программы. Например, даже если язык бестиповый, мы можем сделать над ним какую-то надстройку, которая будет приписывать каждой переменной типы, и он будет проверяться каждый раз при вызове предиката, правильное ли значение было передано в этот предикат на этапе выполнения. Такой контроль позволяет избежать многих ошибок. Если мы проверяем соответствие типов на входе в каждую функцию, то, по крайне мере, при несоответствии выполнение будет прервано.

Можно заметить, что в той или иной степени динамическим контролем обладают все системы программирования, поскольку при попытке совершения запрещенной операции с объектами различных типов зачастую возникает ошибка времени выполнения.

Логика предикатов первого порядка и соответствующие системы логического программирования содержат встроенные возможности по динамическому контролю типов в виде структурных термов. Предикаты не применяются к значениям, имеющим неподходящую структуру – т.е. с учетом обозначений к значениям другого типа. В случае с Прологом можно оборачивать определенные значения в соответствующие структурные термы. Если перепутаем параметры, передаваемые в предикат, – несоответствие типов приведет к тому, что аргументы будут унифицироваться неправильно и будет сразу отказ. Это лучше, чем если бы такого контроля вообще не было. Но, на самом деле, все не так хорошо, как кажется на первый взгляд. Ошибкой это все-таки не будет, будет просто неуспех. Если хотим, чтобы выдавалась ошибка типизации, нужно описать еще одно правило, если в случае того, что что-то не то было передано, выдавалось сообщение об этом. 

Однако интерес представляет именно статический контроль типов, который позволяет обнаруживать ошибки в программах до их выполнения, т.е. по сути дела на этапе разработки, а не тестирования. Для этого необходимо произвести расширение логики предикатов понятием системы типов – т.е. формальной аксиоматической системы со своими аксиомами и правилами вывода, целью которой будет проверка соответствия типов в выражениях логики предикатов.

### Система типов. Типизация в логических языках. Многослойная логика предикатов

В логическом программировании к использованию типизации пришли не сразу, поскольку исчисление предикатов (его логическое происхождение) обычно не использует их. Изначально логические и функциональные языки были бестиповыми, что соответствовало структуре базовых математических теорий (логики и лямбда исчисления). Действительно, значениями переменной в логике могут являться произвольные термы сколь угодно сложной структуры, что затрудняет применения понятия типы данных в том виде, в котором он определяется в императивных языках. Кроме того, системы искусственного интеллекта, для реализации которых в значительной мере создавались первые логические и функциональные языки, призваны были оперировать слабоструктурированными сильносвязаными данными, для которых попытки типизации привели бы к уменьшению выразительности либо возрастанию сложности моделей.

В логическом программировании тип обычно представляет собой набор термов, связанных с позицией аргумента, отражающий понимание программистом, какой вид терма ожидается в этой позиции аргумента.  Было показано, что типы полезны во всех парадигмах программирования, поскольку они могут помочь обнаружить логические ошибки в программе. Типы вводятся в логическое программирование, прежде всего для того, чтобы отличать значимые от бессмысленных термов и предложений, тем самым фиксируя ошибки на ранней стадии разработки программы. Однако типы не так широко распространены в логическом программировании, как в императивном и функциональном программировании. 

В пролог-системах не надо сообщать никакой информации, например, как объявление типа данных, потому что всю информацию она распознает через систему объектов. Существует классификация объектов данных. Пролог-система распознает тип объекта по его синтаксической форме в тексте программы. Это возможно благодаря тому, что синтаксис Пролога предписывает различные формы записи для различных типов объектов данных. Так, например, атомы можно отличить от переменных по тому, что переменные начинаются с прописной буквы, тогда как атомы – со строчной.

Если мы хотим получить хороший язык программирования с контролем типов, нас интересует статический контроль типов.  Для логического языка статический контроль типов является очень осмысленным механизмом. Для того чтобы его изобрести, строится теория, как и для функциональных языков, называется система типов Майкрофта  О’Кифа (Mycroft-O’Keefe). Она базируется на многосортной логике предикатов. Идея состоит в том, что у нас параллельно с формальной аксиоматической системой логического вывода строится еще одна система вывода типов для каждого из термов, которые участвуют в этом логическом выводе. Строится она таким образом, что шаг логического вывода не нарушает правильности типизации. Нам достаточно с помощью некоторого процесса вывода типов проверить правильность типизации исходных выражений, что обеспечивает некоторое свойство корректности, которое говорит о том, что шаг логического вывода сохраняет правильность типизации, т.е. можно дальше не заботиться о проверке типов на этапе выполнения. Вполне естественно, что для таких систем типизации приходится часто использовать такие понятия, как полиморфизм, параметрическая типизация. Например, для использования предикатов для работы со списками, нам надо требовать от этих предикатов, чтобы понятие списка было полиморфным, т.е. чтобы мы могли использовать список чего бы то ни было. И такими полиморфными понятиями оперировать в процессе вывода типов. Также используется понятие вывода типов, когда система программирования может сама понимать, какого же типа значения входят в некоторое выражение. 

### Правила выводов типов

Как строится такая система типизации? В самом общем случае у нас есть множество типов или, поскольку логика предикатов называется многосортной, сортов Т. Это множество, как правило, бесконечное и помимо некоторых встроенных типов (char, integer etc) содержит в себе построение других типов, т.н. конструкторы типов. Например, список целых чисел, список булевских переменных, список списков целых чисел – это все некоторые типы, которые строятся из примитивных с помощью таких конструкторов. Для каждого терма мы можем ввести понятие объявление типа, где мы берем некоторую конструкцию, которая ставит в соответствие терму некоторый тип. Множество таких приписываний, когда мы приписываем терму его тип, называется окружением. Т.е. мы на текущий момент говорим, что у нас есть какое-то выражение, и мы хотим проверить, правильно ли оно типизировано. Оно правильно типизировано, если переменные внутри имеют какие-то приписанные типы. Окружение – это предположение о типах термов. Окружение в простейшем случае – это просто набор соответствий. И из любого окружения может вывести некоторое заключение. Например, если у нас есть Х типа integer и Т типа list(integer), то из этого мы можем вывести с помощью системы вывода типов, что [X|T] имеет тип list(integer). Это понятие выводимости. Есть множество правил вывода, которые позволяют нам говорить о том, что если из окружения можно вывести какие-то посылки, то можно также вывести и какие-то другие посылки. Конструирование типов происходит на основе многосортной логики предикатов.

Как строится многосортная логика предикатов? Множество типов задается набором элементарных типов, прямой суммой и функциональным конструктором. Функциональный конструктор позволяет нам по любому типу построить функцию выражения из типа какого-то другого типа. Мы имеем возможность конструировать тип с помощью конструкторов из примитивных. Фактически, в реализациях языков, всегда заданы какие-то базовые типы. В этом случае окружение, по которому мы будем строить систему вывода, умеет сопоставлять типы предикатам, структурным термам и переменным. 

Правила вывода основные следующие. Во-первых, вводится понятие порядка на множестве типов, т.е. если некий объект имеет некий частный тип, и в то же время этот тип является частью какого-то более общего, то мы можем сделать вывод, что этот объект имеет и более общий тип. Во-вторых, если у нас есть некоторая функция от n аргументов и n аргументов таких же типов, а функция из n аргументов имеет тип Τ, то можно вывести, что результат применения этой функции к аргументам, будет иметь тип Τ. То же самое происходит и с предикатами. В-третьих, существует правило вывода для импликации. Если антецедент имеет какой-то тип, то мы можем сделать вывод, что консеквент имеет такой же тип. 

### Корректность системы типов

Если мы можем сказать, что выражение является корректно типизированным, то из него, с помощью правил вывода, можно получить некоторое следствие. При этом выполняется свойство, что если из правильно типизированного выражения делается шаг вывода, то автоматически получается правильно типизированное выражение. Такое свойство называется корректностью системы типов относительно формальной системы вывода. Иными словами, что если из некоторого окружения выводится некоторое утверждение Т, которое является корректно типизированным, если возможно доказать корректную типизированность Т в этом окружении, а из Т с помощью формальной системы мы получаем выржение С, то в этих же предположениях С также будет правильно типизировано. С точки зрения системы программирования это означает, что если мы проверили правильность программы в начале, то мы можем дальше забыть про проверку типов. Т.е. статический контроль типов полностью покрывает правильность типизации на всем продолжении выполнения программы. 

### Режимы доказательства. Классы конкретизации. 

В логических языках важно учитывать, что предикаты можно использовать в разных контекстах, в зависимости от того, что передается в предикат, какие из аргументов конкретизированы. То, в каком контексте вызывается предикат, в плане того какие аргументы являются конкретизированными, а какие нет, называется режимом его доказательства. Каждый режим доказательства имеет свое дерево вывода, т.е. то, как будет строиться SLD резолюция для контекста такого вызова. Это будут принципиально различные деревья. Для каждого из режимов доказательства есть специфика выполнения предикатов, которая может быть учтена системой программирования.  Например, Mercury для каждого режима доказательства предиката основного строит свой код. При этом некоторые режимы доказательства являются частными случаями друг друга. Поэтому мы можем рассматривать только некоторые основные режимы доказательства, из которых потом строятся все остальные.

Режим доказательства, в простейшем случае, определяется тем, какие переменные являются входными, а какие выходными. Входная переменная это переменная, которая была конкретизирована к моменту вызова предиката, выходная – была свободной, а стала конкретизированной. Но этого недостаточно. В логическом программировании по переменной не всегда можно сказать конкретизирована она или нет. И возможен предикат, у которого режим доказательства такой, что он принимает на вход «непонятную» переменную, а на выход выдает ее с уже подставленными значениями. Например, принимает шаблон списка, а выдает всевозможные заполнения этого шаблона. Поэтому только понятия входных и выходных переменных оказывается недостаточно. Надо ввести понятие, которое называется класс конкретизации. Он показывает то, как конкретизирована переменная. Простейший класс конкретизации: free – свободная переменная и ground – полностью конкретизированная переменная. Помимо этого возможны полуконкретизированные переменные.

### Детерминизм

Помимо режима доказательства оказывается, что в каждом из этих режимов предикат может иметь различный детерминизм. Возможны 3 результата работы предиката – когда, мы получаем 0 решений, когда получаем 1 решение и когда получаем более 1 решения. Также, надо обратить внимание, возможен ли отказ при выполнении предиката. 

Если мы имеем 0 решений и отказ невозможен, то что-то пошло не так, потому что такого не может быть в принципе. Если решений 0 и отказ возможен, значит, что при выполнении предиката всегда будет отказ. Это специальный вид детерминизма, особого интереса он не представляет. Если мы имеет 1 решение и отказ невозможен – это детерминированный предикат, классическая функция, которая всегда по результату дает результат. Если мы имеем 1 решение и отказ возможен – это полудетерминированная функция, т.е. на некоторых аргументах она как будто бы неопределенна, а на остальных она ведет себя как функция. Если решение более 1 и отказ невозможен – это мульидетерминированный предикат, а если отказ возможен, то недетерминированный. Еще есть детерминированный выбор, т.е. если у нас предикат является мультидетерминированным, выдает несколько решений, нас интересует только одно, в этом случае может описать его как выбор. Здесь подразумевается, что система программирования будет заинтересована в том, чтобы найти одно решение, взять его, а остальные уже не искать (аналог отсечения).
 
Рассмотрим, наконец, существующие языки.

### Prolog 

Prolog является бестиповым языком, то есть у него имеется один универсальный тип данных, называемый термом, покрывающий все возможные типы в рамках языка. Prolog использует динамический контроль типов, осуществляемый во время работы программы. Сами термы делятся на простые и структурные, простые в свою очередь на константы и переменные, а константы делятся на атомы и числа. 

 1. Атом – имя общего назначения, не имеющее неотъемлемого значения.
 2. Числа. Могут быть целыми и вещественными. 
 3. Переменные обозначаются строкой, состоящей из букв, цифр и символов подчеркивания, и начинаются с буквы верхнего регистра или подчеркивания. Переменные напоминают переменные в логике, поскольку они являются заполнителями для произвольных термов.
 4. Составной терм представляет собой атом, называемый «функтором», и ряд «аргументов», которые снова являются термами. Составные термы обычно записываются как функтор, за которыми следует разделенный запятыми список аргументов, который содержится в круглых скобках. Количество аргументов называется арностью этого терма. Атом можно рассматривать как составной терм арности ноль.

Особые случаи:

Список –  упорядоченный набор термов. Он обозначается квадратными скобками с членами, разделенными запятыми или, в случае пустого списка, []. Списки –  очень важны, поскольку они добавляют возможность иметь структуру, которая не имеет предопределенного количества элементов. Поскольку нам не нужно объявлять какие-либо типы данных, элементы, которые могут быть помещены в список, могут быть очень разнообразными (числа, символы, все типы терминов, другие списки). 

Строки – последовательность символов, заключенных в кавычки, эквивалентна списку (числовых) кодов символов, обычно в кодировке локального символа, или Unicode, если система поддерживает Unicode.

### VisualProlog 

Самое существенное отличие VisualProlog от эдинбургской версии (т.н. "классического" Пролога) — наличие в нем строгой типизации данных для повышения скорости трансляции и выполнения программ. В начале программы на VisualProlog обычно располагаются разделы описаний доменов (типов данных) и предикатов. В VisualProlog отсутствует возможность рассматривать правила как данные, т. е. добавлять и удалять их во время работы, сопоставлять имя предиката с переменной. Изменяемой частью программы является внутренняя база данных (их может быть несколько). Во время выполнения программы в нее можно добавлять и из нее можно удалять факты.

Программа содержит разделы:

  * Домены (domains) – описание типов данных.
  * Константы (constants) –имя и соответствующее ему значение.
  * Факты (facts) – истинные предикаты.
  * Предикаты (predicates) – объявление нестандартных предикатов.
  * Предложения (clauses) – факты и правила, необходимые Прологу для разрешения цели программы.
  * Цель (goal) – цель программы, сформулированная на языке Prolog. (Обязательный)

Встроенные типы доменов – символы, целые числа, действительные числа, строки, символьные имена, ссылочный тип, файлы. Для добавления новых доменов данных их описывают в разделе domains, там же можно добавлять структурные (составные) домены, аналогичные структурным термам классического Prolog’а.

### Mercury

Mercury - язык функционально-логического программирования нового поколения.  Часть синтаксиса заимствована у Prolog’а. Mercury имеет несколько плюсов в сравнении с классическим Prolog’ом:

  * система типов и режимов предикатов.
  * элементы функционального программирования.
  * возможность работы с функциями высших порядков.
  * автоматическая оптимизация.
  * большая библиотека предикатов.
  * модульное программирование.

Структура программы на языке Mercury:

  * :−module – заголовок модуля.
  * :−interface – интерфейсная часть, то есть, то что мы делаем доступным другим модулям. Для работы программы хотя бы один модуль должен экспортировать предикат main.
  * :−import_module – импорт, то есть, то  что мы хотим взять из других модулей. 
  * :-type – здесь задаются пользовательские типы данных.
  * :−pred – определение предиката, в нем указываются типы аргументов, режимы предиката и варианты детерминизма для каждого из режимов.
  * :-func – определение функции.
  * :-mode – установление режима для предиката или функции, если он не был указан в определении. 
  * Каждая программа в Mercury должна иметь определение предиката main, с которого начинает работу программа.
  * :−implementation – содержит реализацию всех необходимых предикатов.Описание реализации предикатов ничем не отличается от аналогичного в Prolog’е.

Встроенные или определенные в библиотеках типы:

  * Примитивные: char, int, float, string.
  * Предикаты.
  * Функции.
  * Кортежи.
  * Универсальный тип.
  * Все типы Prolog.

### Вывод
Ключевым преимуществом использования типизированного языка программирования вместо нетипизированного является то, что компилятор способен выявлять больше ошибок. Это делается автоматически с помощью статического анализа, и система может указывать на местоположение ошибки более или менее точно. Для типизированных логических программ компьютер может проверять ошибку типа аналогичным образом, как для функциональных и процедурных языков. Типы в логических программах позволяют автоматически проверять соответствие описаний и правил вывода.

Плюсами бестиповых логических языков, на пример Prolog, является простота и быстрота написания программ на нем. Не нужно задумываться над используемыми типами данных и над режимами предикатов (как в Mercury). Обучение логическому программированию на нем так же легче. Но есть и определенные минусы. Отсутствие статического контроля типов в классическом Prolog приводит к сложности отладки, и некоторые баги могут выявиться неожиданно спустя долгое время использования программы. Интерпретируемая концепция делает его намного более медленным, чем классические императивные языки. Так же существенным недостатком классического Prolog является его неполная декларативная семантика, что часто заставляет задумываться в процессе написания программы о способе доказательства Prolog утверждений, то есть об процедурные семантики интерпретатора.

С другой стороны, типизированные языки логического программирования (VisualProlog и Mercury) лишены многих недостатков классического Prolog. Строгая типизация позволяет отлавливать множество ошибок, связанных с несогласованностью типов, еще на этапе компиляции программы. Так как программы компилируемые, то их работа во многом не уступает по времени императивным языкам.
VisualProlog и Mercury больше подходят для разработки серьезного программного обеспечения, а классический Prolog для обучения основам логического программирования.

### Литература

 1. Types in Logic Programming. Frank Pfenning. (1992)
 2. Modes and Types in Logic Programming. Smaus, Jan-Georg. (1999)
 3. Logic Programming. Frank Pfenning. (2007)
 4. On Types and Type Consistency in Logic Programming. Gregor Meyer. (2000)
